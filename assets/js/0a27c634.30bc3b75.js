"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[637],{2636:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=n(5893),s=n(1151);const a={},r="Gitlab Integration",l={id:"CI Integration/gitlab",title:"Gitlab Integration",description:"There are two ways to integrate.",source:"@site/docs/5-CI Integration/gitlab.md",sourceDirName:"5-CI Integration",slug:"/CI Integration/gitlab",permalink:"/golangci-test/docs/CI Integration/gitlab",draft:!1,unlisted:!1,editUrl:"https://github.com/fridaybyte/golangci-test/tree/main/packages/create-docusaurus/templates/shared/docs/5-CI Integration/gitlab.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/golangci-test/docs/intro"},next:{title:"Future",permalink:"/golangci-test/docs/Architecture/Future"}},o={},c=[{value:"Simple approach",id:"simple-approach",level:2}];function g(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",mermaid:"mermaid",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"gitlab-integration",children:"Gitlab Integration"}),"\n",(0,i.jsx)(t.p,{children:"There are two ways to integrate."}),"\n",(0,i.jsx)(t.h2,{id:"simple-approach",children:"Simple approach"}),"\n",(0,i.jsx)(t.p,{children:"Each branch generates the split file during the first pipeline.\nFollowing pipelines use the cached version of the split file."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'stages:\n  - tests\n\nunit_tests:\n  stage: tests\n  parallel: 2\n  script:\n    # Gitlab Env variables are detected automatically. That\'s why\n    # there is no need to pass them explicitly by params such as:\n    # --split-index=$CI_NODE_INDEX\n    # --split-total=$CI_NODE_TOTAL\n    - golangci-test test --split-file=.golangci-test-splits.json --fallback=even\n  cache:\n    policy: pull\n  artifacts:\n    key: "$CI_COMMIT_REF_NAME"\n    paths:\n      - test_out_*.json\n      - coverage_*.txt\n\nunit_tests_merger:\n  stage: tests\n  needs: [ "unit_tests" ]\n  script:\n    # In the following, lines, asterisk is used as a wildcard. \n    # It\'s a not feature of golangci-test, \n    # but a feature called globbing implemented by most shells. \n    # Read more here: https://tldp.org/LDP/abs/html/globbingref.html \n    - golangci-test split --output=.golangci-test-splits.json --merge ./test_out_*.json\n    - golangci-test covmerge ./coverage_*.out > coverage.out\n    # TODO: is `out` the standard extension for coverage? :D\n  artifacts:\n    paths:\n      - coverage.txt\n  cache:\n    policy: push\n    paths:\n      - .golangci-test-splits.json\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Pipeline defined in the above ",(0,i.jsx)(t.em,{children:"yaml"})," file will generate pipeline as\nshown in the diagram below."]}),"\n",(0,i.jsx)(t.mermaid,{value:'---\ntitle: Flow for the scripts in initial and consecutive pipelines\n---\nstateDiagram-v2\n    U1: Running Gitlab Job "Unit Tests - 1st instance"\n    U2: Running Gitlab Job "Unit Tests - 2nd instance"\n    M: Merger and the splitter\n    state unit_tests_trigger <<fork>>\n    state unit_tests_merger <<join>>\n    state U1 {\n        state if1 <<choice>>\n        init1: Trying to load splits file \\n from the pulled cache\n        load1: Loading splits from the \\n splits file pulled from cache\n        generate1: Generating test groups \\n based on sorted package names\n        run1: Running tests from the group 1 and \\n storing output in files\n        [*] --\x3e init1: Gitlab pulls data from cache\n        init1 --\x3e if1\n        if1 --\x3e generate1: Splits File \\n does not exist\n        if1 --\x3e load1: Splits File \\n does exist\n        generate1 --\x3e run1\n        load1 --\x3e run1\n        run1 --\x3e [*]: Gitlab stores generated execution time \\n and coverage output in artifacts\n    }\n    state U2 {\n        state if2 <<choice>>\n        init2: Trying to load splits file \\n from the pulled cache\n        load2: Loading splits from the \\n splits file pulled from cache\n        generate2: Generating test groups \\n based on sorted package names\n        run2: Running tests from the group 2 and \\n storing output in files\n        [*] --\x3e init2: Gitlab pulls data from cache\n        init2 --\x3e if2\n        if2 --\x3e generate2: Splits File \\n does not exist\n        if2 --\x3e load2: Splits File \\n does exist\n        generate2 --\x3e run2\n        load2 --\x3e run2\n        run2 --\x3e [*]: Gitlab stores generated execution time \\n and coverage output in artifacts\n    }\n    [*] --\x3e unit_tests_trigger: Start pipeline \\n Gitlab triggers unit tests job in parallel\n    unit_tests_trigger --\x3e U1\n    unit_tests_trigger --\x3e U2\n    U1 --\x3e unit_tests_merger\n    U2 --\x3e unit_tests_merger\n    state M {\n        [*] --\x3e init: Gitlab pulls data from artifacts\n        init: Trying to load artifacts\n        state artifacts_exist <<choice>>\n        init --\x3e artifacts_exist\n        artifacts_exist --\x3e fail: Data does not exist\n        artifacts_exist --\x3e generate: Data exists\n        generate: Generating splits and merged coverage \\n based on loaded data\n        fail: Return error\n        generate --\x3e [*]: Gitlab Pushes the generated \\n files to the cache\n        fail --\x3e [*]: Gitlab Fails the job\n    }\n    unit_tests_merger --\x3e M: Execution time of tests and \\n coverage output is passed in artifacts\n    M --\x3e [*]: Finish pipeline\n'})]})}function p(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}}}]);